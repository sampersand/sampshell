#!zsh

typeset -g +x prompt_sampshell_var_lines=11
typeset -g +x prompt_sampshell_var_short_git=12
typeset -g +x prompt_sampshell_var_long_git=13
typeset -g +x prompt_sampshell_var_ruby_version=14
typeset -g +x prompt_sampshell_var_time_diff=15
typeset -g +x prompt_sampshell_var_time_str=16
typeset -g +x prompt_sampshell_var_stock_price=17
typeset -g +x prompt_sampshell_var_stock_good=18

# setopt noprompt{bang,cr,percent,subst} "prompt${^prompt_opts[@]}"
#
# if [[ -z $prompt_newline ]]; then
# 	# This variable needs to be set, usually set by promptinit.
#	typeset -g prompt_newline=$'\n%{\r%}'
# fi


# Track the rough time a shell command began execution, so that we can get a rough
# time estimate of the duration. Note that it's not exact, especially if other
# `preexec` functions are executed after this one.
function prompt_sampshell_preexec {
	typeset -gFH PROMPT_SAMPSHELL_LAST_EXEC_TIME=$EPOCHREALTIME
}

# Executed right before a line is drawn; we use it to populate `psvar`.
function prompt_sampshell_precmd {
	emulate -L zsh
	# Get the current duration as soon as possible, for calculating the duration
	# of a command, Note it's not at all exact, especially if this function isn't
	# the first precmd function.
	typeset -F now=$EPOCHREALTIME # for calculating the duration

	# Set the amount of stored lines; replace `0` with an empty string (for `%V`)
	psvar[prompt_sampshell_var_lines]=${${#_SampShell_stored_lines}:#0}

	_SampShell-prompt-git-hook1

	if zstyle -T ':prompt:sampshell:ruby-version' display; then
		psvar[prompt_sampshell_var_ruby_version]=${$(ruby --version)[2]} || true
	fi

	prompt_sampshell_time_to_human $now
}

## The function that's used to fetch the git status.
function _SampShell-prompt-git-hook1 {
	emulate -L zsh # Reset the shell to the default ZSH options

	psvar[prompt_sampshell_var_long_git]= psvar[prompt_sampshell_var_short_git]= # Empty the variables

	## Ensure we're even displaying git
	zstyle -T ":prompt:sampshell:git:${(q)PWD}" display || return 0

	## Configure variables for the `__git_ps1` function
	local GIT_PS1_{HIDE_IF_PWD_IGNORED,SHOW{UNTRACKEDFILES,UPSTREAM,{DIRTY,CONFLICT}STATE}}
	zstyle -T ":prompt:sampshell:git:dirty:$PWD"     display && GIT_PS1_SHOWDIRTYSTATE=1
	zstyle -T ":prompt:sampshell:git:untracked:$PWD" display && GIT_PS1_SHOWUNTRACKEDFILES=1
	zstyle -T ":prompt:sampshell:git:conflict:$PWD"  display && GIT_PS1_SHOWCONFLICTSTATE=1
	zstyle -T ":prompt:sampshell:git:hidepwd:$PWD"   display && GIT_PS1_HIDE_IF_PWD_IGNORED=1
	zstyle -t ":prompt:sampshell:git:stash:$PWD"     display && GIT_PS1_SHOWSTASHSTATE=1
	zstyle -t ":prompt:sampshell:git:upstream:$PWD"  display && GIT_PS1_SHOWUPSTREAM=1

	## Perform the substitution
	local GIT_PS1_STATESEPARATOR= # Set to an empty string so there's no separator
	psvar[prompt_sampshell_var_long_git]=${$(__git_ps1 'â‡„%s')/\%\%/!} # the `/%%/!` replaces `%` with my `!`
	psvar[prompt_sampshell_var_short_git]=$psvar[prompt_sampshell_var_long_git]

	## If there's a prefix pattern, then set `psvar[prompt_sampshell_var_short_git]` to that replacement.
	local pattern
	if zstyle -s ":prompt:sampshell:git:$PWD" pattern pattern; then
		psvar[prompt_sampshell_var_short_git]=${(*)psvar[prompt_sampshell_var_short_git]/${~pattern}/â€¦}
	fi
}

# TODO: is there a way to replace this with a unix command?
function prompt_sampshell_time_to_human {
	float now=$1

	if (( !PROMPT_SAMPSHELL_LAST_EXEC_TIME )) return
	float diff='now - PROMPT_SAMPSHELL_LAST_EXEC_TIME'

	# Make it red if the difference is more than 3s
	psvar[prompt_sampshell_var_time_diff]=
	if (( diff > 1 )) psvar[prompt_sampshell_var_time_diff]=1

	float -F5 seconds='diff % 60'
	integer minutes='(diff /= 60) % 60'
	integer hours='(diff /= 60) % 24'
	integer days='(diff /= 24)'

	local tmp
	if (( days )) tmp+=${days}d
	if (( hours )) tmp+=${tmp:+ }${hours}h
	if (( minutes )) tmp+=${tmp:+ }${minutes}m
	psvar[prompt_sampshell_var_time_str]=${tmp:+ }${seconds}s

	PROMPT_SAMPSHELL_LAST_EXEC_TIME=
}

function prompt_sampshell_periodic {
	emulate -L zsh -o ERR_RETURN
	typeset -u ticker
	typeset -i period time now
	typeset -F2 price last
	zstyle -s ':prompt:sampshell:stock' ticker ticker
	zstyle -s ':prompt:sampshell:stock' period period || period=$PERIOD # default to the var

	local file=${XDG_CACHE_HOME:-~/.cache}/sampshell/stockprice

	now=$(date +%s)
	if [[ -e $file ]] {
		read time price < $file
	}

	last=$price
	if (( time + period <= now )) {
		# There's probably a better way to get stock prices than grepping the
		# html output of a google webpage lol
		price=$(curl -s "https://www.google.com/finance/quote/$ticker:NYSE" \
			| rg -o 'data-last-price="([^"]*)"' -r '$1')

		if [[ ! -d ${file:h} ]] mkdir -p $file:h # make the file's enclosing dir if needed
		print $now $price >! $file
	}

	psvar[prompt_sampshell_var_stock_price]=$price
	if (( last == price )) {
		# do nothing with the `prompt_sampshell_var_stock_good`
	} elif (( last < price )) {
		psvar[prompt_sampshell_var_stock_good]=1
	} else {
		psvar[prompt_sampshell_var_stock_good]=
	}
}


function prompt_sampshell_help {
	print '
		usage: prompt sampshell [default|minimal|full]
			default: the normal view
			minimal: removes some unneeded things, like RPS1 and git
			full: more expanded view than default; doesnt hide paths or git branches
	'
}

function prompt_sampshell_setup {
	#################################################################################################
	#                                             Setup                                             #
	#################################################################################################

	# Figure out the kind that's being used; fail on an invalid one
	local kind=${1:-default}
	if [[ $kind != (default|minimal|full) ]] {
		prompt_sampshell_help >&2
		return 1
	}

	prompt_opts=(percent subst cr sp) # We use percent; TODO: we don't need subst if we fix histfile
	typeset -g PS1='' RPS1='' # Clear both PS1 and RPS1

	# We only do precmd and preexec if we're not in a minimal prompt
	if [[ $kind != minimal ]] {
		add-zsh-hook precmd prompt_sampshell_precmd

		zmodload -F zsh/datetime p:EPOCHREALTIME
		typeset -gFH PROMPT_SAMPSHELL_LAST_EXEC_TIME=$EPOCHREALTIME
		add-zsh-hook preexec prompt_sampshell_preexec
	}

	#################################################################################################
	#                                           Setup PS1                                           #
	#################################################################################################

	local timefmt
	# Still need to figure out which prompt we want...
	if ! zstyle -s ':prompt:sampshell:time' format timefmt; then
		# timefmt='%D{%_I:%M:%S.%. %p}'
		timefmt='%(t.%f%K{cyan}DING!%k.%*)' # hehe, add a ding in
	fi

	## Beginning segment: `[<time> <hist> <exit> <shlvl> <job#> <lines>]`
	PS1+='%B%F{blue}[%b'                       # [
	PS1+="%F{cyan}$timefmt "                   #   Current time
	PS1+='${${HISTFILE:+%f}:-%F{red\}}%U%!%u ' #   History Number; red if disabled; TODO: find a way to not require histfile
	PS1+='%(?.%F{green}âœ”.%F{red}âœ˜%B)%?%b'      #   Previous exit code
	PS1+='%(2L. %F{red}SHLVL=%L.)'             #   (SHLVL, if >1)
	PS1+='%(1j.%F{166} (%j job%(2j.s.)).)'     #   (job count, if >0)
	# how many lines are stored; minimal shells don't need this
	if [[ $kind != minimal ]] { # TODO: do we wnat this to be disabled in minimal shells?
		PS1+="%(${prompt_sampshell_var_lines}V.%f (%${prompt_sampshell_var_lines}v).)"                     #   (amnt stored lines, if >0)
	}
	PS1+='%B%F{blue}]%b '                      # ]

	## Add the `user@host` if we're either SSH'd into something, or the zstyle has it enabled
	if (( $+SSH_CONNECTION )) || zstyle -t ':prompt:sampshell:host' display; then
		PS1+='%F{242}%n@%m%f '
	fi

	## The path; in full mode, display the full thing. Otherwise, only display the first and then
	# the remaining last 3 segments (or the full thing if there's more)
	PS1+='%F{11}'
	if [[ $kind == full ]] {
		PS1+='%~ '
	} else {
		PS1+='%(5~.%-1~/â€¦/%3~.%~) ' # trailing part of the path
	}

	## Git status; we don't display it in a minimal prompt
	if [[ $kind != minimal ]] {
		__git_ps1 >/dev/null 2>&1 # <-- TODO: why does this need to always be run?
		# emulate sh -c "autoload -RUk ${(q)SampShell_ROOTDIR}/zsh/prompt/__git_ps1"; __git_ps1 >/dev/null 2>&1

		# Only expand the full thing if there's a significant amount of space left.
		PS1+='%F{43}'
		if [[ $kind == full ]] {
			PS1+="%${prompt_sampshell_var_long_git}v"
		} else {
			# PS1+='%-$((COLUMNS * 4 / 5))(l.%'${prompt_sampshell_var_short_git}'v.%'${prompt_sampshell_var_long_git}'v) '
			PS1+="%-100(l.%${prompt_sampshell_var_long_git}v.%${prompt_sampshell_var_short_git}v)"
		}
	}

	PS1+='%F{8}%#%f ' # ending %

	#################################################################################################
	#                                  Setup RPS1, if not minimal                                   #
	#################################################################################################

	# Set rps1 to the ruby version and the time difference, if we're displaying that
	if [[ $kind != minimal ]] {
		RPS1="%(${prompt_sampshell_var_ruby_version}V.ðŸ’Ž%F{red}%${prompt_sampshell_var_ruby_version}v%f.)"
		RPS1+=' ['
		RPS1+="%F{%(${prompt_sampshell_var_time_diff}V.red.green)}%${prompt_sampshell_var_time_str}v%f"

		local _tmp
		if zstyle -s ':prompt:sampshell:stock' ticker _tmp; then
			RPS1+=" %(${prompt_sampshell_var_stock_good}V.%F{green}ðŸ“ˆ.%F{red}ðŸ“‰)\$%${prompt_sampshell_var_stock_price}v%f"
			if [[ ! -v PERIOD ]] {
				zstyle -s ':prompt:sampshell:stock' period PERIOD || PERIOD=1800
			}
			add-zsh-hook periodic prompt_sampshell_periodic
		fi
		RPS1+=']'

		setopt transient_rprompt # TODO: How to unset this
	}
}

prompt_sampshell_setup "$@"
