#!zsh

x () source ~ss/zsh/prompt/prompt_sampshell_setup

function prompt_sampshell_precmd {
	typeset -ga psvar=() # clear psvar

	if (( $#HISTFILE )) psvar[2]=1
	if (( $#_SampShell_stored_lines )) psvar[3]=$#_SampShell_stored_lines

	_SampShell-prompt-git-hook
	unset RPS1
}

## The function that's used to fetch the git status.
function _SampShell-prompt-git-hook {
	emulate -L zsh # Reset the shell to the default ZSH options

	psvar[4]= psvar[5]= # Empty the variables

	## Ensure we're even displaying git
	zstyle -T ":sampshell:prompt:git:${(q)PWD}" display || return 0

	## Configure variables for the `__git_ps1` function
	local GIT_PS1_{HIDE_IF_PWD_IGNORED,SHOW{UNTRACKEDFILES,UPSTREAM,{DIRTY,CONFLICT}STATE}}
	zstyle -T ":sampshell:prompt:git:dirty:$PWD"     display && GIT_PS1_SHOWDIRTYSTATE=1
	zstyle -t ":sampshell:prompt:git:stash:$PWD"     display && GIT_PS1_SHOWSTASHSTATE=1
	zstyle -T ":sampshell:prompt:git:untracked:$PWD" display && GIT_PS1_SHOWUNTRACKEDFILES=1
	zstyle -T ":sampshell:prompt:git:conflict:$PWD"  display && GIT_PS1_SHOWCONFLICTSTATE=1
	zstyle -T ":sampshell:prompt:git:hidepwd:$PWD"   display && GIT_PS1_HIDE_IF_PWD_IGNORED=1
	zstyle -t ":sampshell:prompt:git:upstream:$PWD"  display && GIT_PS1_SHOWUPSTREAM=1

	## Perform the substitution
	local GIT_PS1_STATESEPARATOR= # Set to an empty string so there's no separator
	psvar[4]=${$(__git_ps1 '⇄%s ')/\%\%/!} # the `/%%/!` replaces `%` with my `!`
	psvar[5]=$psvar[4]

	## If there's a prefix pattern, then set `psvar[5]` to that replacement.
	local pattern
	if zstyle -s ":sampshell:prompt:git:$PWD" pattern pattern; then
		psvar[5]=${(*)psvar[5]/${~pattern}/…}
	fi
}

function prompt_sampshell_setup {
	prompt_opts=(percent subst)

	local timefmt
	typeset -g PS1=''

	add-zsh-hook precmd prompt_sampshell_precmd

	if ! zstyle -s ':sampshell:prompt:time' format timefmt; then
		timefmt='%D{%_I:%M:%S.%. %p}'
		timefmt='%*'
	fi

	PS1+='%B%F{blue}[%b'                   # [
	PS1+="%F{cyan}$timefmt "               #   Current time
	PS1+='%(2V.%f.%F{red})%U%!%u '         #   History Number; red if disabled.
	PS1+='%(?.%F{green}✔.%F{red}✘%B)%?%b'  #   Previous exit code
	PS1+='%(2L. %F{red}SHLVL=%L.)'         #   (SHLVL, if >1)
	PS1+='%(1j.%F{166} (%j job%(2j.s.)).)' #   (job count, if >0)
	PS1+='%(3V.%f (%3v).)'                 #   (amnt stored lines, if >0)
	PS1+='%B%F{blue}]%b '                  # ]

	# By default, the user and host are always displayed. This can be disabled by
	# setting their `display` to false, or by setting an `expected` value. If the
	# expected value is set but none of its values are equal, the host/user will be
	# displayed in bold and red.
	() {
		# NOTE: Don't change the condition's orderings; the `elif` below relies
		# on `expected` being executed second.
		if ! zstyle -T ':sampshell:prompt:user' display ||
		     zstyle -t ':sampshell:prompt:user' expected $USER
		then
			# Do nothing; Either an explicit opt-out, or we matched.
		elif (( $? == 2 )) then
			PS1+='%F{242}%n' # `expected` was undefined, so use the default
		else
			PS1+='%F{red}%B%n%b' # ERR! `expected` didn't contain `$USER`
		fi

		# (Same layout as `user`)
		if ! zstyle -T ':sampshell:prompt:host' display ||
		     zstyle -t ':sampshell:prompt:host' expected $HOST
		then
			# Do nothing
		elif (( $? == 2 )) then
			PS1+='%F{242}@%M'
		else
			PS1+='%F{red}%B@%M%b'
		fi

		# Add a space if either a user or host were added.
		[[ ${PS1: -1} != ' ' ]] && PS1+=' '
	}

	# set the path
	PS1+='%F{11}' # color
	PS1+='%(5~.%-1~/…/%3~.%~)' # trailing part of the path

	# git, if we're displaying it
	if zstyle -T ':sampshell:prompt:git' display; then
		emulate sh -c "autoload -RUk ~ss/zsh/prompt/__git_ps1"
		# Only expand the full thing if there's a significant amount of space left.
		PS1+=' %F{43}%-$((COLUMNS * 4 / 5))(l.%4v.%5v)'
	fi

	PS1+='%F{8}%#%f ' # ending %
}

prompt_sampshell_setup
