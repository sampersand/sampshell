#!zsh

## Parallelize a function by making a new job once per argument given
# Support for when the shell is ZSH, when we explicitly have `-e`.
[ -n "$ZSH_VERSION" ] && setopt LOCAL_OPTIONS GLOB_SUBST SH_WORD_SPLIT

if [ "${1-}" = -- ]; then
   shift
elif [ "${1-}" = -e ]; then
   SampShell_scratch=1
   shift
elif [ "$#" = 0 ] || [ "$1" = -h ] || [ "$1" = --help ]; then
   if [ "$1" = -h ] || [ "$1" = --help ]; then
      set -- 0
   else
      set -- 64
   fi
   {
      echo "usage: SampShell_parallelize_it [-e] [--] fn [args ...]"
      echo "(-e does shell expansion on args; without it, args are quoted)"
   } >&"$((1 + (! $1) ))"
   return "$1"
fi

# Make sure a function was given
if ! command -v "$1" >/dev/null 2>&1; then
   echo 'SampShell_parallelize_it: no function given' >&2
   unset -v SampShell_parallelize_it
   return 1
fi

# Make sure the function is executable
if ! command -v "$1" >/dev/null 2>&1; then
   printf 'SampShell_parallelize_it: fn is not executable: %s\n' "$1" >&2
   return 1
fi

while [ "$#" -gt 1 ]; do
   # If we're expanding...
   if [ -n "${SampShell_scratch-}" ]; then
      # Unset `SampShell_scratch` so the child process doesn't see it
      unset -v SampShell_scratch

      # Run the function
      "$1" $2 &

      # Remove argument #2
      SampShell_scratch=$1
      shift 2
      set -- "$SampShell_scratch" "$@"

      # Set it so we'll go into this block next time.
      SampShell_scratch=1
   else
      # Run the function
      "$1" "$2" &

      # Remove argument #2
      SampShell_scratch=$1
      shift 2
      set -- "$SampShell_scratch" "$@"

      # unset it so won't run the expand block.
      unset -v SampShell_scratch
   fi
done

unset -v SampShell_scratch
