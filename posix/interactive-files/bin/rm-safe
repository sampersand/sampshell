#!/bin/sh

# Safety first
set -o nounset

scriptname=$(basename "$0")

# This function is equivalent to `rm -i`, except it will remove
# files/folders that are empty. If the first argument starts with `-` (and isn't `--`),
# then it's forwarded
# `rm`, except safer:
#   For every argument given on the command line, if it refers to an
#   a file or directory, prompt for deletion. However, if it's empty,
#   just go ahead and delete it without asking.
#
#   If the first argument starts with `-` (and isn't `--`), then forward
#   all the arguments to the `rm` command and don't do any custom logic.

# If the first argument is a `--`, then just delete that and interpret the rest
# as filenames to delete.
if [ "$#" -ne 0 ] && [ "$1" = -- ]; then
	shift
elif [ "$#" -eq 0 ] || [ "$1" = -h ] || [ "$1" = --help ]; then
	cat <<EOS >&2
usage: $scriptname [-h/--help] [--] file [...]
       $scriptname -(any other flag) ...
The same as 'rm -id', except it will remove empty files/directories without
asking for confirmation. If the first argument starts with '-' and is neither
'-h'/'--help' nor '--', all the arguments are forwarded to 'rm'.

Note: since atomic operations are impossible, there's no way to guarantee that
a file will only be deleted when empty (e.g. if someone writes to it after
the script checks for size). There's no real way around this...
EOS
	exit 255
elif [ "${1#-}" != "$1" ]; then
	# The first character is a `-`, then forward to the builtin rm
	command -p rm "$@"
	exit
fi

# Keep track of the last non-zero exit status
exit_status=0

for filename; do
	rm-if-empty "$filename" || command -p rm -i -- "$1" || exit_status=$?
done

exit "$exit_status"
