#!/bin/sh

# Safety first
set -o nounset

# Overwrite 'IFS' even if it was somehow given to us
nl='
'
IFS=" "" $nl"
unset nl

scriptname="$(basename -- "$0"; echo x)"; scriptname="${scriptname%x}"

usage () { cat; exit 255; } <<EOS >&2
usage: ${scriptname} [-h/--help] ...
       ${scriptname} [options] [--] source target
       ${scriptname} [options] [--] source ... directory
options:
   -h, --help              print help, then exit.
   -r, --rename            enable rename mode (see below)
   -R, --no-rename         disable rename mode
   -c, --clobber-empty     overwrite empty files/folders
   -C, --no-clobber-empty  don't overwrite empty files/folders
returns:
   0   if everything was successful
   254 if an unknown argument was given

Without the '-r' flag, this acts the same as 'mv -i', except it will try to
overwrite empty files/directories without confirmation. (Note that it's
impossible to guarantee this, as atomic operations arne't really possible).
With the '-r' option, a "rename" move will be perfomed (see below). If any other
flags are given, then all the arguments are forwarded to the builtin 'mv'.

A "rename" operation only works when provided a directory as the last argument;
passing a file in will result in an error. It will attempt to move the file to
the path '\$directory/{file basename}'. If that file already exists, it will
attempt to move the file to '\$directory/{file stem} #{file ext}', where '#' is
a number (starting from 2). The number will be incremented until a nonempty
file is found. ## (it might) This doesn't suffer from the atomic issues, and this operation
will never override extant files.
EOS

rename_mode=
clobber_empty=

# Parse command line options
while test "$#" -ne 0
do
   case "$1" in
      -h | --help)
         usage ;;

      --)
         shift
         break ;;

      -r | --rename)
         rename_mode=1 ;;

      -R | --no-rename)
         rename_mode= ;;

      -c | --clobber-empty)
         clobber_empty=1 ;;

      -C | --no-clobber-empty)
         clobber_empty= ;;

      -*)
         exit 254;;

      *)
         break ;;
   esac
   shift
done

# If no arguments are given, then error out with the usage.
test "$#" -le 1 && usage

echo "todo: rename_mode and clobber_empty"

try_move () {
   if ! test -e "$1"
   then
      printf >&2 '%s: cannot move %s: No such file or directory\n' "${scriptname}" "$1"
      return 1
   fi

   # TODO: fix `\n` stuff
   base="$(basename -- "$2"; echo .)"; base="${base%?.}"
   stem="${base%%.*}"
   ext="${base#"$stem"}"
   root="$(dirname "$2")/$stem"

   idx=1
   while test -e "$1"
   do
      if test "${idx}" -gt 1
      then
         target="${root} ${idx}${ext}"
      else
         target="${root}${ext}"
      fi

      if test -e "${target}"
      then
         idx="$((idx+1))"
         continue
      fi

      # try to move it in; if it doesn't succeed
      # try to move the file into the target
      command -p mv -n -- "$1" "${target}" || return
   done
}

# If two arguments are given, and the second isn't a directory, assume the first form
if test "$#" -eq 2 && ! test -d "$2"
then
   try_move "$1" "$2"
   exit
fi

# The target folder is the last argument; make sure it exists.
target_folder=$(eval "echo \"\${$#}\"")
if ! test -d "${target_folder}"
then
   printf >&2 '%s: cannot move files into %s: Not a directory\n' "${scriptname}" "${target_folder}"
   exit 11
fi

last_status=0
while test "$#" -gt 1
do
   try_move "$1" "${target_folder}/$(basename "$1")" || last_status=$?
   shift
done

exit "${last_status}"
