#!/bin/sh

# Safety first
set -o nounset

# Overwrite 'IFS' even if it was somehow given to us
nl='
'
IFS=" "" $nl"
unset nl

scriptname="$(basename -- "$0"; echo x)"; scriptname="${scriptname%?x}"

die () {
   status=$1 msg="%s: $2"'\n'
   shift 2
   printf "$msg" "$scriptname" "$@"
   exit "$status"
}

shortusage () { cat <<EOS; [ "$#" -eq 0 ] && exit 255; } >&2
usage: ${scriptname} [-h/--help] ...
       ${scriptname} [options] [--] source target
       ${scriptname} [options] [--] source ... directory
EOS

longusage () { shortusage 0; cat <<EOS; exit 255; } >&2
options:
   -h, --help              print help, then exit.
   -r, --rename            enable rename mode (see below)
   -R, --no-rename         disable rename mode
   -c, --clobber-empty     overwrite empty files/folders
   -C, --no-clobber-empty  don't overwrite empty files/folders
returns:
   0   if everything was successful
   254 if an unknown argument was given

Without the '-r' flag, this acts the same as 'mv -i', except it will try to
overwrite empty files/directories without confirmation. (Note that it's
impossible to guarantee this, as atomic operations arne't really possible).
With the '-r' option, a "rename" move will be perfomed (see below). If any other
flags are given, then all the arguments are forwarded to the builtin 'mv'.

A "rename" operation only works when provided a directory as the last argument;
passing a file in will result in an error. It will attempt to move the file to
the path '\$directory/{file basename}'. If that file already exists, it will
attempt to move the file to '\$directory/{file stem} #{file ext}', where '#' is
a number (starting from 2). The number will be incremented until a nonempty
file is found. ## (it might) This doesn't suffer from the atomic issues, and this operation
will never override extant files.
EOS

rename_mode=
clobber_empty=

# Parse command line options
while [ "$#" -ne 0 ]; do
   case "$1" in
      -h | --help)
         longusage ;;

      --)
         shift
         break ;;

      -r | --rename)
         rename_mode=1 ;;

      -R | --no-rename)
         rename_mode= ;;

      -c | --clobber-empty)
         clobber_empty=1 ;;

      -C | --no-clobber-empty)
         clobber_empty= ;;

      -*)
         die 254 'unknown option: %s' "$1" ;;

      *)
         break ;;
   esac
   shift
done

# If no arguments are given, then error out with the usage.
[ "$#" -le 1 ] && shortusage

# Arg 1 is source, arg2 is destination
try_move () {
   if [ ! -e "$1" ]; then
      printf >&2 '%s: cannot move %s: No such file or directory\n' "${scriptname}" "$1"
      return 1
   fi

   idx= target="$2"

   while
      # Delete the target file/dir if it's empty.
      if [ -n "${clobber_empty}" ]; then
         if [ -f "${target}" ] && [ ! -s "${target}" ]; then
            command -p rm -f -- "${target}" || return
         elif [ -d "${target}" ] && ! ls -A1q -- "${target}" | grep -q .; then
            command -p rm -fd -- "${target}" || return
         fi
      fi

      # try to move the source file, returning an error if there's a problem.
      command -p mv -n -- "$1" "${target}" || return

      # Now, after moving it, does it exist?
      [ -e "$1" ]
   do
      # If we aren't renaming, and it exists, oops error!
      [ -z "$rename_mode" ] && return 1

      # If we haven't created an index, then setup all the arguments
      if [ -z "$idx" ]; then
         idx=1
         base="$(basename -- "$2"; echo x)"; base="${base%?x}"
         stem="${base%%.*}"
         ext="${base#"$stem"}"
         dir="$(dirname -- "$2"; echo x)"; dir="${dir%?x}"
         root="$dir/$stem"
      fi

      # Now set the target and let's try again
      target="$root $((idx=idx+1))$ext"
   done
   return 0
}

# If two arguments are given, and the second isn't a directory, assume the first form
if [ "$#" -eq 2 ] && [ ! -d "$2" ]; then
   try_move "$1" "$2"
   exit
fi

# The target folder is the last argument; make sure it exists.
target_folder=$(eval "echo \"\${$#}\"")
if ! [ -d "${target_folder}" ]; then
   die 11 'cannot move files into %s: Not a directory' "${target_folder}"
fi

last_status=0
while [ "$#" -gt 1 ]; do
   base="$(basename "$1"; echo x)"; base="${base%?x}"
   try_move "$1" "$target_folder/$base" || last_status=$?
   shift
done

exit "${last_status}"
