#!/usr/bin/env ruby

# This file is incredibly overengineered haha.

def usage! success = false
  $stdout = $stderr unless success

  puts <<~USAGE; exit(success)
    usage: #$0 [-c compiler] [-o output] [compiler opts ...] [prelude ...] main [-- main-arguments]
    compiles C code using 'compiler', which defaults to 'cc'. 'opts' can be
    interspersed within arguments.
    - prelude is done before 'main'
    - lots of defaults are imported by default
    - P is a macro shorthand for printf(...), putchar('\\n')
  USAGE
end

class Program
  def Program::MakeOutputFile()
    $EXECUTABLE_FILE = %x<mktemp>.chop
    $?.success? or fail('cannot make temp file')
    trap 'EXIT', 'File.delete $EXECUTABLE_FILE' and fail('made two temp files')
    $EXECUTABLE_FILE
  end

  attr('compiler')
  attr('compilerOpts')

  public def executable
    @executable ||= Program::MakeOutputFile()
  end

private

  def initialize argv=ARGV
    @compiler = 'cc'
    @compilerOpts = []
    @prelude = []

    self.parseOptions(argv)
  end

  def parseOptions argv
    while (arg = argv.shift()) do
      case (arg)
      when '-h'   then usage! true
      when /^-c/  then @compiler = $' || argv.shift() or usage!()
      when /^-o/  then @output   = $' || argv.shift() or usage!()
      when '--'   then break()
      when /^-.*/ then @compilerOpts << arg
      else @prelude << arg
      end
    end

    usage! unless (@main = @prelude.pop())
  end

public

  def writeProgram
    read, write = IO.pipe()

    printf write, DATA.read, prelude: @prelude.join("\n"), main: @main
    write.close()

    return( read )
  end
end

def executeProgram program
  system(
    { 'RUNC_ARGV0' => program.executable },
    program.compiler,
    '-xc',
    '-o',
    program.executable,
    '/dev/fd/10',
    *program.compilerOpts,
    10 => program.writeProgram(),
    exception: true
  )
rescue Errno::ENOENT
  abort "cannot find compiler: #{program.compiler}"
rescue RuntimeError
  $@ = [] # No backtrace in exit
  raise
else
  # Don't use `exec` so we can run our `trap` to remove it
  system( [program.executable] * 2, *$* )
end

executeProgram Program.new(ARGV)
exit Process::last_status.exitstatus

__END__
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <limits.h>
#include <unistd.h>
#define P(...) (printf(__VA_ARGS__),putchar('\n'))

%<prelude>s

int main(int argc, const char **argv) {
  %<main>s;
}
