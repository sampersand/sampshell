#!/bin/sh

\unalias -a # in case we are `.`d

# Safety First!
set -ef

# Unset all the variables that're used within the program. We have to be careful
# with the naming of these variables so they don't conflict with any environment
# variables we may have inherited. (We `unset` these variables to remove their
# "export"-edness, as just assigning to a blank string leaves them exported.)
#
# Note that setting the `-a` flag, which is used to to pass through inherited
# variables, does not affect these variables; they're never passed onwards.
unset -v __clenv_unset_vars \
         __clenv_user_vars \
         __clenv_user_vars_index \
         __clenv_all_variables \
         __clenv_verbose \
         __clenv_dry \
	 __clenv_default_vars \
	 __clenv_cmd \
	 __clenv_tmp \
	 __clenv_name \
	 __clenv_value \

# The list of variables that are added by default to all invocations unless -a
# or -n are specified.
__clenv_default_vars=${SampShell_clenv_DEFAULTS_VARS-'TERM HOME SHLVL LANG'}

readonly scriptname="${0##*/}"
usage () { cat; } <<USAGE
usage: $scriptname [-DVansp] [-v name[=value] ...] [-u name ...]
       $(printf "%${#scriptname}s") [utility [argument ...]]
options:
    -D              Enables "dry mode"--don't actually run the program; Sets -V.
    -V              Enables "verbose mode," so it prints out the invocation
    -a              Pass _all_ environment variables in by default.
    -n              Don't set any_arguments by default, including essential ones
    -s              Pass in env variables prefixed with "SampShell_"
    -p              Shorthand for -vPATH
    -v name[=value] Puts 'name' in the env of the called utility. If 'value' is
                    omitted, it defaults to the current value of 'name' (which,
                    if unset, is an error.)
    -u name         Unset 'name'. If both -v and -u are given, -u wins.

"clean-env": A wrapper around 'env' which (by default) forwards a few essential
arguments. Without arguments, prints out the variables
USAGE

__clenv_cmd='exec env'
while getopts 'hDVanpSP:v:u:' opt; do
	case $opt in

	h) usage; exit;;

	# Dry mode and verbose mode. Enabling dry mode also enables verbose.
	# [ -n "$__clenv_dry"     ] && __clenv_cmd=": $__clenv_cmd"
	# [ -n "$__clenv_verbose" ] && __clenv_cmd="PS4=; set -x; $__clenv_cmd"
	D) __clenv_dry=1 __clenv_verbose=1 ;;
	V) __clenv_verbose=1 ;;

	# Flags for specifying groups of variables to pass onwards.
	a) __clenv_all_variables=1 ;;
	n) __clenv_all_variables=  __clenv_default_vars= ;;
	p) __clenv_default_vars="$__clenv_default_vars PATH" ;;
	s) __clenv_default_vars="$__clenv_default_vars $(awk 'BEGIN {
		for (k in ENVIRON)
			if(k ~ /^SampShell[_-][a-zA-Z_0-9-]+$/) print k
	}')";;
	v)
		__clenv_name=${OPTARG%=*}
		__clenv_value=${OPTARG#"$__clenv_name"}

		if [ -n "$__clenv_value" ]; then
			__clenv_value=${__clenv_value#=}
		else
			case $__clenv_name in
				*[!a-zA-Z0-9_-]*)
					echo >&2 "cant get default name for env var with special chars"
					exit 1
			esac
			# TODO: ERR ON UNSET?
			eval "__clenv_value=\$$__clenv_name"
		fi

		cmdline_variable "$__clenv_name" "$__clenv_value"
		# Use `set` so we get local variables
		__clenv_tmp=__clenv_var_$((__clenv_user_vars_index += 1))
		eval "$__clenv_tmp=\$__clenv_value"
		__clenv_user_vars="$__clenv_user_vars \"$__clenv_name=\$$__clenv_tmp\"" ;;

	## Unset a variable
	u) __clenv_unset_vars="$__clenv_unset_vars $OPTARG" ;;

	# Everything else is an error
	?) exit 2 ;;
	esac
done

## Finish argument parsing.
shift $(( OPTIND - 1 ))

# If any arguments were given, then take a look at them.
if [ $# -ne 0 ]; then
	# Ensure we find the program, as passing `PATH=` to env will overwrite it.
	if ! __clenv_tmp=$(command -v -- "$1"); then
		echo >&2 "unable to locate the program '$1'; exiting"
		exit 1
	else
		shift
		set -- "$__clenv_tmp" "$@"
	fi
fi

__clenv_cmd='exec env'
[ -n "$__clenv_dry"     ] && __clenv_cmd=": $__clenv_cmd"
[ -n "$__clenv_verbose" ] && __clenv_cmd="PS4=; set -x; $__clenv_cmd"

unset $__clenv_unset_vars # TODO: See if there's a way to make this not overwrite `__clenv` vars.

if [ -z "$__clenv_all_variables" ]; then
	__clenv_cmd="$__clenv_cmd -i"

	for __clenv_tmp in $__clenv_default_vars; do
		eval 'test -z ${'$__clenv_tmp'+1}' && continue
		__clenv_cmd="$__clenv_cmd \"$__clenv_tmp=\$$__clenv_tmp\""
	done
fi

# If no variables to unset, then just expand out the easy way
if [ -z "$__clenv_unset_vars" ]; then
	__clenv_cmd="$__clenv_cmd $__clenv_user_vars"
else
	for __clenv_tmp in  $__clenv_user_vars; do
		for __clenv_tmp2 in $__clenv_unset_vars; do
			case $__clenv_tmp in
				\"${__clenv_tmp2}=*)
					continue 2
			esac
		done
		__clenv_cmd="$__clenv_cmd $__clenv_tmp"
	done
fi

eval "$__clenv_cmd \"\$@\""
