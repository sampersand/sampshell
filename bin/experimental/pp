#!/usr/bin/env -S ruby -Ebinary

require 'optparse'

# $*.replace %w[ -h -x --c-escapes -h hello world ]
OptParse.new do |op|
  op.on 'Options'
  op.on '--tty', 'Assume that stdout is a tty (for defaults) even if it is not'
  op.on '--number-lines', 'Number outputs by adding `%5d:` before them; used when -f isnt present'
  op.on '--arguments', 'Interpret arguments as strings themselves, not as filenames'
  op.on '--no-trailing-newline', 'Suppress trailing newline; only helpful when --arguments isnt set'

  op.on 'What to escape'
  op.on '--escape-space', 'Escape spaces; when in visual, they standout, otherwise they use \x20' do $escape_space = true end
  op.on '--escape-backslash', 'Escape backslashes; defaults to off when in visual' do $escape_backslash = true end
  $escape_tab = true
  op.on '--escape-tab', 'Escape tabs' do $escape_tab = true end
  $escape_newline = true
  op.on '--dont-escape-newlines', 'Disable escaping newlines; useful when escape whitespace is set' do $escape_newline = false end

  op.on 'Escape Methods'
  $c_escapes = true
  op.on '--c-escapes', 'Use C escapes when available (default)' do $c_escapes = true end
  op.on '-x', '--no-c-escapes', "Don't use C escapes; output in hex" do $c_escapes = false end

  # op.on '--no-c-escapes', 'Output C escapes in \xHEX instead'
  op.on '--codepoints', 'Output larger values as codepoint escapes, instead of the char itself' do $codepoints = true end
  op.on '-v', '--[no-]visualize', 'Enable visual effects; when enabled, defaults for other escapes change.' do |x| $visual = x end

  op.on 'Encodings'
  op.on '--input-encoding=XYZ', 'Set the input encoding'
  op.on '--output-encoding=XYZ', 'Set the input encoding'
  op.on '--binary', 'Sets the input/output to handle binary data---no utf8'
  op.on '--locale', 'Sets the input/output to the locale (default)'
  op.on '--utf-8', 'Sets the input/output to handle utf8; invalid bytes will be highlighted in red'
  op.on '--utf-8-error', 'Same as --utf-8, except the exit status will be nonzero when errors'

  # p op.class.instance_methods false
  op.on 'ENVIRONMENT: PP_BEGIN_STANDOUT; PP_END_STANDOUT; PP_BEGIN_ERR; PP_END_ERR'


=begin
large things: normally themselves, optional `\u{codepoint}`
invalid: `\xBYTE` but in bad standout
prints: always htemselves
backslash: `\` when in standout mode, `\\` when not, or when requested
space: itself unless explicitly requested otherwise. then in standout, or with an escape
newline, tab: either themselves or escaped with `\n`/`\t`
other whitespace: escaped unless asked for
controls: `\c` if avaliable by default; can be set to `\xSEQ` (or `\u{codepoint}`?)


=end
  ## by default:


  op.parse! rescue op.abort #"#{op.program_name}: #$!"
  if $*.empty? then $files = true; $*.replace %w[-] end
end

BEGIN_STANDOUT = ENV.fetch('PP_BEGIN_STANDOUT', "\e[7m")
END_STANDOUT   = ENV.fetch('PP_END_STANDOUT',   "\e[27m")
BEGIN_ERR      = ENV.fetch('PP_BEGIN_ERR',      "\e[37m\e[41m")
END_ERR        = ENV.fetch('PP_END_ERR',        "\e[49m\e[39m")

OUTPUT = String.new(capacity: 4096 * 8)#, encoding: $output_encoding)

def escape_error(char)
  OUTPUT.concat(BEGIN_ERR, char.each_byte.map { "\\x%02X" % _1 }.join, END_ERR)
end

def visualize_c(char, **b)
  visualize char.each_byte.map { "\\x%02X" % _1 }.join, **b
end

def visualize(val, alt=val, start: BEGIN_STANDOUT, stop: END_STANDOUT)
  if $visual
    OUTPUT.concat(start, val, stop)
  else
    OUTPUT.concat(alt)
  end
end

def escape(char)
  OUTPUT.concat char.inspect
end

def handle(line)
  line.chars do |char|
    unless char.valid_encoding?
      visualize_c char, start: BEGIN_ERR, stop: END_ERR
      next
    end

    case char
    when $escape_space && ' ' then visualize char, '\x20'
    when $escape_backslash && '\\' then visualize '\\\\'
    when "\t" then $escape_tab ? visualize($c_escapes ? '\t' : '\x09') : OUTPUT.concat(char)
    when "\n" then $escape_newline ? visualize($c_escapes ? '\n' : '\x0A') : OUTPUT.concat(char)

    when "\x00"..."\x20" then char.inspect.length < 6 && $c_escapes ? visualize(char.inspect[1..-2]) : visualize_c(char)  # TODO: C escapes
    when $codepoints && ->{ _1.codepoints.sum > 0x7f } then char.codepoints.each { visualize '\u{%x}' % _1 }
    else OUTPUT.concat char
    end
  end
end

$OUTPUT_ENCODING = 'UTF-8'

while gets
  handle $_.force_encoding($OUTPUT_ENCODING)
  OUTPUT.display
  OUTPUT.clear
end


__END__

OptParse.accept Encoding do |encoding|
  if encoding == '?'
    puts "Valid encodings: #{Encoding.name_list.join(', ')}"
    exit
  end

  begin
    Encoding.find encoding
  rescue ArgumentError
    raise "invalid encoding '#{encoding}'. (Use '?' to list all encodings)"
  end
end

$standout = true
$escape_whitespace = true
$escape_newlines = nil
$suppress_trailing_newline = false

ESCAPES = []
OptParse.new do |op|
# $escape = []
# OptParse.new do |op|
#   op.on '--escape=WHAT', Array, 'What to escape' do |x| p x end

#   op.on ''
#   # op.on '-w', '--[no-]whitespace'

#   op.parse! rescue op.abort
# end
# __END__

  op.on 'Define Escapes'
  op.on '-w', '--[no-]dont-escape-whitespace', "Don't escape non-space whitespace." do |ews|
    $escape_whitespace = !ews
  end

  op.on '-l', '--[no-]dont-escape-lines', "Don't escape newlines." do |enl|
    $escape_newlines = !enl
  end

  op.on '-U', '--escape-larger', 'Escape things larger than 0xff' do
    $escape_larger = true
  end

  op.on '-\\', '--[no-]escape-backslash', 'Also escape backslashes. Defaults to on when standout is enabled' do |bs|
    $escape_backslash = bs
  end

  op.on 'others'

  op.on '-i', '--input-encoding=ENCODING', Encoding, 'Set input encoding (default: UTF-8)' do |enc|
    $input_encoding = enc
  end

  op.on '-o', '--output-encoding=ENCODING', Encoding, 'Set output encoding (default: the input encoding)' do |enc|
    $output_encoding = enc
  end

  op.on '-n', '--suppress-trailing-newline', 'Do not print out a trailing newline' do
    $suppress_trailing_newline = true
  end

  op.on '-x', '--always-hex', 'Do not display C-style `\r`' do
    $cstyle = false
  end

  op.on '-c', '--cstyle', 'Display escpaes with C-style `\r` etc' do
    $cstyle = true
  end

  op.on '-v', '--[no-]visual', 'Enables standout mode; defaults if tty' do |s|
    $standout = s
  end

  op.on '-a', '--ascii-only', 'Escape upper bits too' do
    $input_encoding = $output_encoding = 'ASCII'
  end

  op.on '-u', '--utf-8', 'Assume input is in UTF-8 format' do
    $input_encoding = $output_encoding = 'UTF-8'
    $escape_larger = false
  end

  op.on '-b', '--binary' do
    $input_encoding = $output_encoding = 'binary'
    $escape_whitespace = true
  end

  op.on '--print', 'print' do $print = true end

  op.on '-f', '--files', 'Interpret arguments as files, not messages to print' do
    $files = true
  end

  op.on '-N', '--number-files', 'Number the input lines' do
    $number_lines = true
  end

  op.on '-t', '--tty', 'Use tty defaults, even if output is not a tty' do
    $isatty = true
  end

  ARGV.replace %w[-f -] if ARGV.empty?

  op.parse! rescue abort "#{op.program_name}: #$!"
  if $*.empty? then $files = true; $*.replace %w[-] end
end

$input_encoding ||= Encoding::UTF_8
$output_encoding ||= $input_encoding
$escape_newlines = $*.empty? if $escape_newlines.nil?
$number_lines = true if !defined?($number_lines) && !$files
$cstyle = true unless defined? $cstyle
$escape_backslash = !$standout if $escape_backslash.nil?

BEGIN_STANDOUT = "\e[7m"
END_STANDOUT = "\e[27m"
BEGIN_ERR = "\e[37m\e[41m"
END_ERR = "\e[49m\e[39m"


C_CODEPOINTS = {
  0=>'\x00', 7=>'\a', 8=>'\b', 9=>'\t', 10=>'\n', 11=>'\v',
  12=>'\f', 13=>'\r', 27=>'\e'
}.freeze

WHITESPACE = [9, 10]

$files and ARGF.set_encoding $input_encoding

OUTPUT = String.new(capacity: 4096 * 8, encoding: $output_encoding)
INPUT_LINE = String.new(capacity: 4096, encoding: $input_encoding)

def escape(what)
  $standout and OUTPUT.concat BEGIN_STANDOUT
  OUTPUT.concat(what)
  $standout and OUTPUT.concat END_STANDOUT
end

eval <<RUBY
def handle
  INPUT_LINE.each_char do |chr|
    unless chr.valid_encoding?
      OUTPUT.concat(BEGIN_ERR, chr.inspect[1..-2], END_ERR)
      next
    end

    codepoint = chr.codepoints.first

    if


    # {$escape_newlines ? 'when 10 then OUTPUT.concat cahr'}
    if $print && chr =~ /[[:print:]]/ then
      OUTPUT.concat chr, '!'
      next
    end

     char = codepoint
    if char == 10 and !$escape_newlines
      OUTPUT.concat char
    elsif (WHITESPACE.include?(char) ? $escape_whitespace : char < 0x20)
      escape ($cstyle && C_CODEPOINTS[char]) || ('\\x%02X' % char)
    elsif char == '\\\\'.ord and $escape_backslash
      escape '\\\\\\\\'
    elsif (0x7F..0xFF).include? char
      escape '\\x%02X' % char
    elsif 0xff < char && $escape_larger
      escape '\\u{%X}' % char
    else
      OUTPUT.concat char
    end
  end

  print OUTPUT
  $ended_with_newline = OUTPUT.end_with? "\\n"
  OUTPUT.clear
end
RUBY

if $files
  while (ARGF.readpartial(4096, INPUT_LINE) rescue nil)
    handle
  end
  puts unless $suppress_trailing_newline || $ended_with_newline
else
  $*.each_with_index do |arg, idx|
    printf "%5d: ", idx+1 if $number_lines
    INPUT_LINE.replace arg
    handle
    puts
  end
end


