#!/usr/bin/env -S ruby -Ebinary

require 'optparse'

$isatty = $stdout.tty?
$arguments = 'auto'
OptParse.new do |op|
  op.on 'Options'
  op.on '--tty', 'Assume that stdout is a tty (for defaults) even if it is not' do $isatty = true end
  op.on '--number-lines', 'Number outputs by adding `%5d:` before them; used when -f isnt present' do $number_lines = true end
  op.on '-n', '--no-trailing-newline', 'Suppress trailing newline; only helpful when --arguments isnt set' do $no_newline = true end

  op.on '-N' do $number_lines = false end
  op.on '-f', '--files', 'Interpret arguments as files to be read; also disables line numbering' do $files = true; $number_lines = false end

  op.on '-h', '--help', 'Print this and then exit' do
    puts op
    exit
  end

  op.on 'What to escape'
  op.on '--escape-space', 'Escape spaces; when in visual, they standout, otherwise they use \x20' do $escape_space = true end
  op.on '-\\', '--[no-]escape-backslash', 'Escape backslashes; defaults to off when in visual' do |eb| $escape_backslash = eb end
  op.on '-t', '--[no-]escape-tab', 'Escape tabs' do |et| $escape_tab = et end
  op.on '--[no-]escape-newline', 'Enables (or not) escaping of newlines' do |en| $escape_newline = en end
  op.on '-l', 'Line-oriented mode: Do not escape newlines' do $escape_newline = false end
  op.on '-U', '--[no-]escape-unicode', 'Escape values larger than 0xff (via \u{...})' do |eu| $escape_unicode = eu end
  op.on '-a', '--escape-all' do $escape_space = $escape_backslash = $escape_tab = $escape_newline = $escape_unicode = true end
  op.on '-w', '--escape-whitespace' do $escape_space = $escape_tab = $escape_newline = true end
  op.on '--escape=WHAT', Array, 'What to escape; use `?` for a list; prefix with `!,` to disable escapes' do |escape|
    escape.each do |arg|
      escape = !arg.slice!(/\A!/)
      case arg
      when 'space', "\s", '\s'   then $escape_space = escape
      when 'tab', "\t", '\t'     then $escape_tab = escape
      when 'newline', "\n", '\n' then $escape_newline = escape
      when 'backslash', '\\', '\\\\' then $escape_backslash = escape
      else op.abort "unknown escape: #{arg}"
      # when 'space' then $escape_space = negate
      end
    end
  end


  op.on 'Escape Methods'
  $c_escapes = true
  op.on '--c-escapes', 'Use C escapes when available (default)' do $c_escapes = true end
  op.on '-x', '--no-c-escapes', "Don't use C escapes; output in hex" do $c_escapes = false end
  op.on '-v', '--visualize', 'Enable visual effects; when enabled, defaults for other escapes change.' do |x| $visual = p x end
  op.on '-V', '--no-visualize', 'Same as --no-visualize' do $visual = false end

  op.on 'Encodings (all inputs are assumed to be binary)'
  op.on '-E', '--encoding=ENCODING', 'The output encoding. (defaults to "locale", set by LC_CTYPE)' do |enc|
    if enc == 'list'
      puts "available encodings: #{(Encoding.name_list - %w[external internal]).join(', ')}"
      exit
    end

    $encoding = Encoding.find enc rescue op.abort
  end

  op.on '-b', '--binary', '--bytes', 'Sets the output encoding to binary data. (equiv to -Ebinary)' do
    $encoding = Encoding::BINARY
  end

  op.on '-u', '--utf-8', 'Sets the output encoding to UTF-8. (equiv to -Eutf-8)' do
    $encoding = Encoding::UTF_8
  end

  op.on '--locale', 'Sets the input/output to the `LC_CTYPE` environment variablelocale (default)' do
    $encoding = Encoding.find('locale')
  end

  op.on '--[no-]encoding-failure-err', 'If enabled (default when not a tty), invalid bytes causes an error' do |efe| $encoding_failure_error = efe end

  op.require_exact = true
  op.on 'ENVIRONMENT: PP_BEGIN_STANDOUT; PP_END_STANDOUT; PP_BEGIN_ERR; PP_END_ERR'

  op.parse! rescue op.abort

  if $arguments == 'auto' && !$isatty
    op.abort "--arguments must be given when not on a tty"
  end
end

BEGIN_STANDOUT = ENV.fetch('PP_BEGIN_STANDOUT', "\e[7m")
END_STANDOUT   = ENV.fetch('PP_END_STANDOUT',   "\e[27m")
BEGIN_ERR      = ENV.fetch('PP_BEGIN_ERR',      "\e[37m\e[41m")
END_ERR        = ENV.fetch('PP_END_ERR',        "\e[49m\e[39m")

$files = !$stdin.tty? if !defined?($files) && $*.empty?
$visual = $isatty unless defined? $visual
$encoding_failure_error = !$isatty unless defined? $visual
$escape_space = $arguments unless defined? $escape_space
$escape_tab = $visual unless defined? $escape_tab
$escape_newline = ($arguments; true) unless defined? $escape_newline
$number_lines = $arguments unless defined? $number_lines
$encoding ||= Encoding.find('locale')

OUTPUT = String.new(capacity: 4096 * 8)#, encoding: $encoding)

def escape_error(char)
  OUTPUT.concat(BEGIN_ERR, char.each_byte.map { "\\x%02X" % _1 }.join, END_ERR)
end

def visualize_c(char, **b)
  visualize char.each_byte.map { "\\x%02X" % _1 }.join, **b
end

def visualize(val, alt=val, start: BEGIN_STANDOUT, stop: END_STANDOUT)
  if $visual
    OUTPUT.concat(start, val, stop)
  else
    OUTPUT.concat(alt)
  end
end

def handle(line)
  line.each_char do |char|
    unless char.valid_encoding?
      visualize_c char, start: BEGIN_ERR, stop: END_ERR
      $ENCODING_FAILED = true
      next
    end

    case char
    when $escape_space && ' ' then visualize char, '\x20'
    when $escape_backslash && '\\' then visualize '\\\\'
    when "\t" then $escape_tab ? visualize($c_escapes ? '\t' : '\x09') : OUTPUT.concat(char)
    when "\n" then $escape_newline ? visualize($c_escapes ? '\n' : '\x0A') : OUTPUT.concat(char)
    when "\x00"..."\x20" then char.inspect.length < 6 && $c_escapes ? visualize(char.inspect[1..-2]) : visualize_c(char)
    else
      if char.codepoints.sum > 0x7F
        if char.bytes.length > 1
          if $escape_unicode
            visualize '\u{%04X}' % char.codepoints.sum
            next
          end
        else
          visualize_c char
          next
        end
      end
      OUTPUT.concat char
    end
  end
end

if !$files
  $*.each_with_index do |arg, idx|
    $number_lines and printf "%5d: ", idx += 1
    handle (+arg).force_encoding($encoding)
    OUTPUT.display
    OUTPUT.clear
    puts; $nl = true
  end
else
  $<.binmode
  while gets
    handle $_.force_encoding($encoding)
    OUTPUT.display
    OUTPUT.clear
  end
  puts unless $no_newline
end

exit 1 if $ENCODING_FAILED && $encoding_failure_error
