#!/usr/bin/env -S ruby -Ebinary

require 'optparse'

$isatty = $stdout.tty?
OptParse.new do |op|
  op.on 'Options'
  op.on '--tty', 'Assume that stdout is a tty (for defaults) even if it is not' do $isatty = true end
  op.on '--number-lines', 'Number outputs by adding `%5d:` before them; used when -f isnt present' do $number_lines = true end
  op.on '-N' do $number_lines = false end
  op.on '-A', '--arguments', 'Interpret arguments as strings themselves, not as filenames' do $arguments = true end
  op.on '-n', '--no-trailing-newline', 'Suppress trailing newline; only helpful when --arguments isnt set' do $no_newline = true end

  op.on 'What to escape'
  op.on '--escape-space', 'Escape spaces; when in visual, they standout, otherwise they use \x20' do $escape_space = true end
  op.on '-\\', '--[no-]escape-backslash', 'Escape backslashes; defaults to off when in visual' do |eb| $escape_backslash = eb end
  op.on '-t', '--[no-]escape-tab', 'Escape tabs' do |et| $escape_tab = et end
  op.on '--[no-]escape-newline', 'Enables (or not) escaping of newlines' do |en| $escape_newline = en end
  op.on '-l', 'Line-oriented mode: Do not escape newlines' do $escape_newline = false end
  op.on '-U', '--[no-]escape-unicode', 'Escape values larger than 0xff (via \u{...})' do |eu| $escape_unicode = eu end
  op.on '-a', '--escape-all' do $escape_space = $escape_backslash = $escape_tab = $escape_newline = $escape_unicode = true end
  op.on '-w', '--escape-whitespace' do $escape_space = $escape_tab = $escape_newline = true end
  op.on '--escape=WHAT', Array, 'What to escape; use `?` for a list; prefix with `!,` to disable escapes' do |escape|
    escape.each do |arg|
      escape = !arg.slice!(/\A!/)
      case arg
      when 'space', "\s", '\s'   then $escape_space = escape
      when 'tab', "\t", '\t'     then $escape_tab = escape
      when 'newline', "\n", '\n' then $escape_newline = escape
      when 'backslash', '\\', '\\\\' then $escape_backslash = escape
      else op.abort "unknown escape: #{arg}"
      # when 'space' then $escape_space = negate
      end
    end
  end


  op.on 'Escape Methods'
  $c_escapes = true
  op.on '--c-escapes', 'Use C escapes when available (default)' do $c_escapes = true end
  op.on '-x', '--no-c-escapes', "Don't use C escapes; output in hex" do $c_escapes = false end
  op.on '-v', '--[no-]visualize', 'Enable visual effects; when enabled, defaults for other escapes change.' do |x| $visual = x end
  op.on '-V', 'Same as --no-visualize' do $visual = false end

  op.on 'Encodings (all inputs are assumed to be binary)'
  op.on '-E', '--encoding=ENC', 'Set the input encoding' do |enc| $output_encoding = Encoding.find enc rescue op.abort end
  op.on '-b', '--binary', 'Sets the input/output to handle binary data---no utf8' do $output_encoding = Encoding::BINARY end
  op.on '--locale', 'Sets the input/output to the locale (default)' do $output_encoding = Encoding.find('locale') end
  op.on '-u', '--utf-8', 'Sets the input/output to handle utf8; invalid bytes will be highlighted in red' do $output_encoding = Encoding::UTF_8 end
  op.on '--[no-]encoding-failure-error', 'If enabled (default when not a tty), invalid bytes causes an error' do |efe| $encoding_failure_error = efe end

  op.require_exact = true
  op.on 'ENVIRONMENT: PP_BEGIN_STANDOUT; PP_END_STANDOUT; PP_BEGIN_ERR; PP_END_ERR'

  op.parse! rescue op.abort
end

BEGIN_STANDOUT = ENV.fetch('PP_BEGIN_STANDOUT', "\e[7m")
END_STANDOUT   = ENV.fetch('PP_END_STANDOUT',   "\e[27m")
BEGIN_ERR      = ENV.fetch('PP_BEGIN_ERR',      "\e[37m\e[41m")
END_ERR        = ENV.fetch('PP_END_ERR',        "\e[49m\e[39m")

$visual = $isatty unless defined? $visual
$encoding_failure_error = !$isatty unless defined? $visual
$escape_space = $arguments unless defined? $escape_space
$escape_tab = $visual unless defined? $escape_tab
$escape_newline = ($arguments; true) unless defined? $escape_newline
$number_lines = $arguments unless defined? $number_lines
$output_encoding ||= Encoding.find('locale')

OUTPUT = String.new(capacity: 4096 * 8)#, encoding: $output_encoding)

def escape_error(char)
  OUTPUT.concat(BEGIN_ERR, char.each_byte.map { "\\x%02X" % _1 }.join, END_ERR)
end

def visualize_c(char, **b)
  visualize char.each_byte.map { "\\x%02X" % _1 }.join, **b
end

def visualize(val, alt=val, start: BEGIN_STANDOUT, stop: END_STANDOUT)
  if $visual
    OUTPUT.concat(start, val, stop)
  else
    OUTPUT.concat(alt)
  end
end

def escape(char)
  OUTPUT.concat char.inspect
end

def handle(line)
  line.chars do |char|
    unless char.valid_encoding?
      visualize_c char, start: BEGIN_ERR, stop: END_ERR
      $ENCODING_FAILED = true
      next
    end

    case char
    when $escape_space && ' ' then visualize char, '\x20'
    when $escape_backslash && '\\' then visualize '\\\\'
    when "\t" then $escape_tab ? visualize($c_escapes ? '\t' : '\x09') : OUTPUT.concat(char)
    when "\n" then $escape_newline ? visualize($c_escapes ? '\n' : '\x0A') : OUTPUT.concat(char)
    when "\x00"..."\x20" then char.inspect.length < 6 && $c_escapes ? visualize(char.inspect[1..-2]) : visualize_c(char)
    else
      if char.codepoints.sum > 0x7F
        if char.bytes.length > 1
          if $escape_unicode
            visualize '\u{%04X}' % char.codepoints.sum
            next
          end
        else
          visualize_c char
          next
        end
      end
      OUTPUT.concat char
    # when ($output_encoding == 'utf-8' && $escape_unicode && ->{ _1.codepoints.sum > 0x7f }) then char.codepoints.each { visualize '\u{%x}' % _1 }
    # when "\x00"..."\x20", ($output_encoding != 'utf-8' && "\x80"...)  then char.inspect.length < 6 && $c_escapes ? visualize(char.inspect[1..-2]) : visualize_c(char)
    # else OUTPUT.concat char
    end
  end
end

if $arguments
  # $*.each { _1.force_encoding $INPUT_ENCODING }
  $*.each_with_index do |arg, idx|
    $number_lines and printf "%5d: ", idx + 1
    handle (+arg).force_encoding($output_encoding)
    OUTPUT.display
    OUTPUT.clear
    puts
  end
  exit
end

ARGF.set_encoding $INPUT_ENCODING

while gets
  handle $_.force_encoding($output_encoding)
  OUTPUT.display
  OUTPUT.clear
end

puts unless $no_newline
exit 1 if $ENCODING_FAILED && $encoding_failure_error
