#!/usr/bin/env -S ruby -Ebinary

require 'optparse'

$isatty = $stdout.tty?
OptParse.new do |op|
  op.on 'Options'

  op.on '-h', '--help', 'Print this and then exit' do
    puts op
    exit
  end

  op.on '--tty', 'Assume that stdout is a tty (for defaults) even if it is not' do $isatty = true end
  op.on '--number-lines', 'Number outputs by adding `%5d:` before them; used when -f isnt present' do $number_lines = true end
  op.on '-n', '--no-trailing-newline', 'Suppress trailing newline; only helpful when --arguments isnt set' do $no_newline = true end

  op.on '-N' do $number_lines = false end
  op.on '-f', '--files', 'Interpret arguments as files to be read; also disables line numbering' do $files = true; $number_lines = false end

  op.on 'What to escape'
  op.on '--escape-space', 'Escape spaces; when in visual, they standout, otherwise they use \x20' do $escape_space = true end
  op.on '-s', '--[no-]escape-surrounding-spaces', 'Escape leading and trailing spaces' do |es| $escape_surrounding_spaces = es end
  op.on '-\\', '--[no-]escape-backslash', 'Escape backslashes; defaults to off when in visual' do |eb| $escape_backslash = eb end
  op.on '-t', '--[no-]escape-tab', 'Escape tabs' do |et| $escape_tab = et end
  op.on '--[no-]escape-newline', 'Enables (or not) escaping of newlines' do |en| $escape_newline = en end
  op.on '-l', 'Line-oriented mode: Do not escape newlines' do $escape_newline = false end
  op.on '-U', '--[no-]escape-unicode', 'Escape values larger than 0xff (via \u{...})' do |eu| $escape_unicode = eu end
  op.on '-a', '--escape-all' do $escape_space = $escape_backslash = $escape_tab = $escape_newline = $escape_unicode = true end
  op.on '-w', '--no-escape-whitespace' do $escape_space = $escape_tab = $escape_newline = false end
  # op.on '--unescape=WHAT', Array, 'What to escape; use `?` for a list; prefix with `!,` to disable escapes' do |escape|
  op.on '--escape=WHAT', Array, 'What to escape; use `?` for a list; prefix with `!,` to disable escapes' do |escape|
    escape.each do |arg|
      escape = !arg.slice!(/\A!/)
      case arg
      when 'space', "\s", '\s'   then $escape_space = escape
      when 'tab', "\t", '\t'     then $escape_tab = escape
      when 'newline', "\n", '\n' then $escape_newline = escape
      when 'backslash', '\\', '\\\\' then $escape_backslash = escape
      else op.abort "unknown escape: #{arg}"
      # when 'space' then $escape_space = negate
      end
    end
  end


  op.on 'Escape Methods'
  $c_escapes = true
  op.on '--c-escapes', 'Use C escapes when available (default)' do $c_escapes = true end
  op.on '-x', '--no-c-escapes', "Don't use C escapes; output in hex" do $c_escapes = false end
  op.on '-v', '--visualize', 'Enable visual effects; when enabled, defaults for other escapes change.' do |x| $visual = p x end
  op.on '-V', '--no-visualize', 'Same as --no-visualize' do $visual = false end

  op.on 'Encodings (all inputs are assumed to be binary)'
  op.on '-E', '--encoding=ENCODING', 'The output encoding. (defaults to "locale", set by LC_CTYPE)' do |enc|
    if enc == 'list'
      puts "available encodings: #{(Encoding.name_list - %w[external internal]).join(', ')}"
      exit
    end

    $encoding = Encoding.find enc rescue op.abort
  end

  op.on '-b', '--binary', '--bytes', 'Sets the output encoding to binary data. (equiv to -Ebinary)' do
    $encoding = Encoding::BINARY
  end

  op.on '-u', '--utf-8', 'Sets the output encoding to UTF-8. (equiv to -Eutf-8)' do
    $encoding = Encoding::UTF_8
  end

  op.on '--locale', 'Sets the input/output to the `LC_CTYPE` environment variablelocale (default)' do
    $encoding = Encoding.find('locale')
  end

  op.on '--[no-]encoding-failure-err', 'If enabled (default when not a tty), invalid bytes causes an error' do |efe| $encoding_failure_error = efe end

  op.require_exact = true
  op.on 'ENVIRONMENT: PP_BEGIN_STANDOUT; PP_END_STANDOUT; PP_BEGIN_ERR; PP_END_ERR'

  op.order! rescue op.abort
end

BEGIN_STANDOUT = ENV.fetch('PP_BEGIN_STANDOUT', "\e[7m")
END_STANDOUT   = ENV.fetch('PP_END_STANDOUT',   "\e[27m")
BEGIN_ERR      = ENV.fetch('PP_BEGIN_ERR',      "\e[37m\e[41m")
END_ERR        = ENV.fetch('PP_END_ERR',        "\e[49m\e[39m")

$files = !$stdin.tty? if !defined?($files) && $*.empty?
$visual = $isatty unless defined? $visual
$encoding_failure_error = !$isatty unless defined? $visual
$escape_surrounding_spaces = !$files unless defined? $escape_surrounding_spaces
$escape_tab = $visual unless defined? $escape_tab
$escape_newline = true unless defined? $escape_newline
$number_lines = !$files && $isatty unless defined? $number_lines
$encoding ||= Encoding.find('locale')

OUTPUT = String.new(capacity: 4096 * 8)#, encoding: $encoding)

def vis_c(char, **b)
  vis char.each_byte.map { |b| "\\x%02X" % b }.join, **b
end

def vis(val, alt=val, start: BEGIN_STANDOUT, stop: END_STANDOUT)
  if $visual
    "#{start}#{val}#{stop}"
  else
    alt
  end
end

ESCAPES = Hash.new
ESCAPES["\0"] = vis('\0') if $c_escapes
ESCAPES["\n"] = "\n" unless $escape_newline
ESCAPES["\t"] = "\t" unless $escape_tab

$c_escapes and %W[\a \b \t \n \v \f \r \e].each do |chr|
  ESCAPES[chr] ||= vis_c chr.inspect[1..-2]
end

# All the lower escapes that haven't been done yet
(0x00...0x20).each { ESCAPES[_1.chr] ||= vis_c(_1.chr) }

## print escapes, barring the escapes that've
(0x20..0x7F).map{ _1.chr $encoding }.each do |char|
  ESCAPES[char] = char
end
ESCAPES["\\"] = vis("\\\\") if $escape_backslash
ESCAPES[" "]  = vis(" ") if $escape_space

# Upper bits, for binary encodings
if $encoding == Encoding::BINARY
  (0x80..0xFF).map{ _1.chr $encoding }.each do |char|
    ESCAPES[char] = vis_c(char)
  end
end

ESCAPES.default_proc = proc do |hash, char|
  hash[char] = if !char.valid_encoding?
    $ENCODING_FAILED = true
    vis_c(char, start: BEGIN_ERR, stop: END_ERR)
  elsif $escape_unicode
    vis('\u{%04X}' % char.codepoints.sum)
  else
    char
  end
end

def handle(line)
  line.each_char do |char|
    OUTPUT.concat ESCAPES[char]
  end
end

if !$files
  $*.each_with_index do |arg, idx|
    $number_lines and printf "%5d: ", idx += 1
    arg = (+arg).force_encoding $encoding
    if $escape_surrounding_spaces
      x = arg.slice!(/\A */) and OUTPUT.concat vis(x)
      rest = arg.slice!(/ *\Z/)
    end
    handle arg
    rest and OUTPUT.concat vis rest
    OUTPUT.display
    OUTPUT.clear
    puts; $nl = true
  end
else
  $<.binmode
  while gets
    handle $_.force_encoding($encoding)
    OUTPUT.display
    OUTPUT.clear
  end
  puts unless $no_newline
end

exit 1 if $ENCODING_FAILED && $encoding_failure_error
