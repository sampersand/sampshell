#!/bin/sh

## clenv -- like 'env', except with a few more QoL features
# Features that env doesn't have:
# 1. Only pass in variables that match a patter (`-m "SampShell_*"`)
# 2. Just have to specify variable names if they already exist (`-vPATH`)
# 3. Commonly needed variables for shells exported by default (TERM, HOME, etc.)
#

# Safety First!
set -efuC

readonly scriptname="${0##*/}"

die () {
	fmt="%s: $1\n"
	shift
	printf >&2 "$fmt" "$scriptname" "$@"
	exit 1
}

# Unset all the variables that're used within the program. We have to be careful
# with the naming of these variables so they don't conflict with any environment
# variables we may have inherited. (We `unset` these variables to remove their
# "export"-edness, as just assigning to a blank string leaves them exported.)
#
# Note that setting the `-a` flag, which is used to to pass through inherited
# variables, does not affect these variables; they're never passed onwards.
unset -v __clenv_user_vars \
         __clenv_all_variables \
         __clenv_verbose \
         __clenv_dry \
         __clenv_underscore \
         __clenv_default_vars \
         __clenv_cmd \
         __clenv_tmp \
         __clenv_name \
         __clenv_value

# The list of variables that are added by default to all invocations unless -a
# or -n are specified.
__clenv_default_vars=${SampShell_clenv_DEFAULTS_VARS-'TERM HOME SHLVL LANG'}

usage () { cat; } <<USAGE
usage: $scriptname [options] [--] [utility [argument ...]]
options:
    -D              Don't actually run the program; Sets -V
    -V              Print the invocation, and any changed variables.

    -a              Pass all environment variables in by default.
    -n, -i          Don't set any arguments by default, including essential ones
    -P altpath      Use 'altpath' to find 'utility' instead of inherited \$PATH
    -L              Lookup 'utility' using \$PATH (not working; do we want this?)

    -v name[=value] Puts 'name' in the env of 'utility'. If 'value' is omitted,
                    it uses the current value (or errors if unset).

    -u name         Unset 'name'. If both -v and -u are given, -u wins.
    -m pattern      Pass in any variables matching the awk pattern.
    -_              Set the '_' variable in the env to the path to the executable
    -p              Shorthand for -vPATH -P\$PATH

"clean-env": A wrapper around 'env' which (by default) forwards a few essential
arguments. Without arguments, prints out the variables
USAGE

validate_variable_name () case $1 in
	__clenv_var_*)
		die 'invalid variable name (cannot start with __clenv_var_): %s' "$1" ;;

	*[!a-zA-Z0-9_-]*)
		die 'invalid variable name (must match [\w_-]): %s' "$1" ;;
esac

# Default the path to find the exe to `$PATH`
__clenv_alt_path=
__clenv_unset_vars=
__clenv_dry=
__clenv_verbose=
__clenv_all_variables=
__clenv_user_vars=

while getopts 'hDV_anipP:m:v:u:U:' opt; do
	case $opt in

	h) usage; exit;;

	# Dry mode and verbose mode. Enabling dry mode also enables verbose.
	D)
		__clenv_dry=1 __clenv_verbose=1 ;;
	V)
		__clenv_verbose=1 ;;
	_)
		__clenv_underscore=1 ;;


	p)
		__clenv_default_vars="$__clenv_default_vars PATH"
		__clenv_alt_path=$PATH ;;
	P)
		__clenv_alt_path=$OPTARG ;;

	# Flags for specifying groups of variables to pass onwards.
	a) __clenv_all_variables=1 __clenv_default_vars= ;;
	[ni]) __clenv_all_variables=  __clenv_default_vars= ;;

	m) __clenv_default_vars="$__clenv_default_vars $(awk 'BEGIN {
		for (k in ENVIRON) if(k ~ ARGV[1]) print k; exit }' "$OPTARG")";;

	v)
		# Fetch the name and optional value from the argument
		__clenv_name=${OPTARG%=*}
		__clenv_value=${OPTARG#"$__clenv_name"}

		# Make sure the name is a valid name
		validate_variable_name "$__clenv_name"

		# If a value was given, use that.
		if [ -n "$__clenv_value" ]; then
			__clenv_value=${__clenv_value#=}
		else
			# Use the value in the environment; abort if not present.
			eval '[ -z "${'$__clenv_name'+1}" ]' && die "variable $__clenv_name is unset."
			eval "__clenv_value=\$$__clenv_name"
		fi

		# Instead of having to figure out escaping with the different variables, instead we
		# use `__clenv_var_XXX` variables
		__clenv_tmp=__clenv_var_${#__clenv_user_vars}
		eval "$__clenv_tmp=\$__clenv_value"
		__clenv_user_vars="$__clenv_user_vars \"$__clenv_name=\$$__clenv_tmp\""
		;;

	## Unset a variable
	u)
		validate_variable_name "$OPTARG"
		__clenv_unset_vars="$__clenv_unset_vars ^$OPTARG$"

		# Unset it from the user vars
		__clenv_user_vars=$(printf '%s' "$__clenv_user_vars" | \
			sed "s/\"$OPTARG=\$__clenv_var_[0-9]*\"//1")
		;;

	U)
		__clenv_unset_vars="$__clenv_unset_vars $OPTARG"
		;;

	# Everything else is an error
	?) exit 2 ;;
	esac
done

## Finish argument parsing.
shift $(( OPTIND - 1 ))

################################################################################
#                          Construct the Command Line                          #
################################################################################

## The way `clenv` works is that we end up constructing a command line, then
# execute it via `eval` later. The final command line looks like:
# 	[PS4=; set -x;]      Print out invocation, for `-V``
# 	[:]                  Don't actually run the `env` command, for `-D`
#   exec                 Replace process with `exec`
#   $(command -pv env)   Path that's guaranteed to have a POSIX-compliant `env`
#   [-i]                 Set unless `-a` is passed, to remove all other vars
#   [TERM=$TERM ...]     Default variables, if they're present, and `-n` not set
#   [foo=bar ...]        user-defined variables to pass in
#   --                   separator
#   [/path/to/utility]   Looked up via `$PATH` / whatever `-P` sets
#   [...]                arguments to utility
##

## We do a lot of checking for paths early on because we `unset` later

# Initialize the command with `exec /path/to/env`
__clenv_cmd="exec $(command -pv env)" || die 'unable to locate `env`'

# Setup debug and verbose options
[ -n "$__clenv_dry"     ]       && __clenv_cmd=": $__clenv_cmd"
[ -n "$__clenv_verbose" ]       && __clenv_cmd="PS4=; set -x; $__clenv_cmd"

# Unless `-a` was supplied, we clear away all other variables.
[ -z "$__clenv_all_variables" ] && __clenv_cmd="$__clenv_cmd -i"

## If an alternative $PATH and utility were both supplied, then replace the
# utility with the version we find.
if [ $# -gt 0 ] && [ -n "$__clenv_alt_path" ]; then
	# Find the path
	if ! __clenv_utility_path=$(PATH=$__clenv_alt_path command -v -- "$1"); then
		die 'unable to locate executable program: %s' "$1"
	fi

	shift
	set -- "$__clenv_utility_path" "$@"

	# TODO: this is a vuln waiting to happen when the utility path has special chars
	[ -n "$__clenv_underscore" ] && __clenv_cmd="$__clenv_cmd \"_=\$__clenv_utility_path\""
fi

## Unset variables we don't need
__clenv_tmp=$(awk 'BEGIN {
	for (k in ENVIRON) {
		for (a in ARGV) {
			if (k ~ ARGV[a]) {
				print k
				break
			}
		}
	}; exit }' $__clenv_unset_vars)
if [ "$__clenv_verbose" ] && [ "${#__clenv_tmp}" -ne 0 ]; then
	printf 'unsetting: %s\n' $__clenv_tmp
fi
unset -v -- $__clenv_tmp

## Add in default variables
for varname in $__clenv_default_vars; do
	if eval '[ -n "${'$varname'+1}" ]'; then
		__clenv_cmd="$__clenv_cmd \"$varname=\$$varname\""
	fi
done

## Add in user variables
__clenv_cmd="$__clenv_cmd $__clenv_user_vars"

## Execute the command
eval "$__clenv_cmd -- \"\$@\""
