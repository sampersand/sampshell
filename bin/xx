#!/bin/zsh

## `xx`: A helper script to repeat a string a certain amount of times
# mnemonic: just like the `xx` operator in raku, or the `x` operator in perl.
##



## Usage function
usage () cat <<USAGE
usage: ${ZSH_SCRIPT:t} [-n] (-w WIDTH | -c COUNT) [--] string
	-n         Don't print the trailing newline
	-c COUNT   Print 'string' COUNT times
	-w WIDTH   Repeat 'string' until WIDTH chars are printed
USAGE



## Parse Command line options
wopts=(-w 80) # Default output options
zparseopts -D -E -K n=no_newline {w,c}+:=wopts h=help # Parse command line options
[[ $1 == -- ]] && shift # `zparseopts` doesn't strip `--`, so we do that ourselves

## Fetch command line option values
msg=$1
style=$wopts[-2] # Style and width are the last two values passed in to `-w` or `-c`; if nothing ...
width=$wopts[-1] # ... was passed in, then the default `-w 80` is used.

## Handle `-h` and validate options.
(( $+help ))  && { usage; exit } # If help was requested, print the usage and exit.
(( $# != 1 )) && { usage >&2; exit 1 } # If not exactly one argument was left over, that's an error.
[[ $width != <-> ]] && { print -- "${ZSH_SCRIPT:t}: width is not an integer: $width" >&1; exit 1 }



## Do the repetition
if [[ $style == -c ]] then
	repeat $width print -nr -- $msg
else
	for (( ; 0 < width; width -= $#msg )) do
		# Note that `%.*s` with a width larger than the string length is a no-op.
		printf '%.*s' $width $msg
	done
fi

## Print the trailing newline unless it was suppressed
[[ $no_newline ]] || print



## Exit successfully
exit 0
