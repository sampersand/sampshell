#!/bin/sh

# `xx`: A helper script to repeat a string a certain amount of times
# mnemonic: just like the `xx` operator in raku, or the `x` operator in perl.

####################################################################################################
#                                          Parse Options                                           #
####################################################################################################

usage () { cat; } <<USAGE
usage: $(basename -- "$0") [-n] [-jSTRING] (-c COUNT | -w WIDTH | -W) [--] string [...]
  -n         Don't print the trailing newline
  -c COUNT   Print 'string' COUNT times
  -w WIDTH   Repeat 'string' until WIDTH chars are printed [default=80]
  -W         Like -w, but uses \$COLUMNS (or stty size)
  -j STRING  String to put between arguments. [default=space]
USAGE

no_newline= count= width=80 join=' '
while getopts 'nWhj:c:w:' option; do
	case $option in
	n) no_newline=1 ;;
	j) join=$OPTARG ;;
	c) count=$OPTARG width= ;;
	w) width=$OPTARG count= ;;
	W) width=${COLUMNS:-$(stty size 2>&- | cut -f2 -d ' ')} count= ;;
	h) usage; exit ;;
	\?) exit 2 ;;
	esac
done

shift $(( OPTIND - 1 ))

# Error out if no string to print was given
if [ $# -eq 0 ]; then
	usage >&2
	exit 1
fi

# Join the arguments. If the `-j` argument is a single character, then we can
# go ahead and use `IFS` for it:
if [ "${#join}" -le 1 ]; then
	tmp=$IFS IFS=$join
	string=$*
	IFS=$tmp
else
	# Otherwise, we need to manually join the arguments
	string=$1
	shift
	while [ $# -ne 0 ]; do
		string=$string$join$1
		shift
	done
fi

# Actually print out the string
if [ -z "$string" ]; then
	# Print nothing for empty strings
	:
elif [ "${#string}" -eq 1 ]; then
	# Special case for single-character strings, we can go through `tr`
	printf "% ${width:-$count}s" "" | tr ' ' "$string"
elif [ -n "$width" ]; then
	# (TODO: Can you optimize this based on printing `$width / ${#string}`
	# full entires and `$width % ${#string}` remainder)
	# We want a `width` iteration
	while [ "$width" -gt 0 ]; do
		printf "%.${width}s" "$string"
		: "$(( width -= ${#string} ))"
	done
else
	# Otherwise, we want a count iteration.
	while [ "$(( count -= 1 ))" -ge 0 ]; do
		printf %s "$string"
	done
fi

# Print out a newline unless it is suppressed
[ -z "$no_newline" ] && echo

# Always return successfully
exit 0
