#!/usr/bin/env ruby

################################################################################
# Banner: Surround messages in boxes, to use for separators in source files.   #
################################################################################
require 'optparse'

OPTIONS = {
  width: 80,
  pre: 0,
  style: '#',
  padding: true,
  justify: :center,
}
ALLOWED_STYLES = %W[# * /]

# Parse options
OptParse.new  do |op|
  op.banner.concat ' [message ...]'

  op.on '-w', '--width=(auto,AMNT)', "Total line width. \"auto\" is the smallest possible that still fits. [default: #{OPTIONS[:width]}]" do |arg|
    if arg == 'auto'
      :auto
    else
      Integer(arg, exception: false) or raise OptParse::InvalidArgument, x
    end
  end

  op.on '-p', '--pre=AMNT', Integer, 'Add AMNT spaces before the banner'
  op.on '-s', '--style=STYLE', ALLOWED_STYLES, "Use STYLE instead. Options: #{ALLOWED_STYLES}. [default: #{OPTIONS[:style]}]"

  op.on '-m', '--multiline', 'Interpret each arg as a separate line'
  op.on '-b', '--blank', 'Add a blank link before and after the banner contents'
  op.on '--copy', 'Pipe output to pbcopy command'
  op.on '--[no-]padding', 'Add padding to the front and end of lines. [default]'

  op.on '-c', '--center-justify', 'Justify text in the center [default]' do
    OPTIONS[:justify] = :center
  end

  op.on '-l', '--left-justify', 'Justify text on the left' do
    OPTIONS[:justify] = :left
  end

  op.on '-r', '--right-justify', 'Justify text on the right' do
    OPTIONS[:justify] = :right
  end

  op.parse! into: OPTIONS rescue op.abort $!
  ARGV.empty? and abort op.help
end

OPTIONS[:multiline] or  ARGV.replace [ARGV.join(' ')]
OPTIONS[:blank]     and (ARGV.unshift ''; ARGV.push '')
OPTIONS[:copy]      and $stdout = IO.popen('pbcopy', 'w')

if OPTIONS[:width] == :auto || OPTIONS[:width] == 0
  OPTIONS[:width] = $*.map(&:length).max + 4 # TODO: use other pres
  OPTIONS[:width] -= 2 unless OPTIONS[:padding]
end

if (OPTIONS[:width] - OPTIONS[:pre]).negative?
  abort "#{File.basename($0)}: -p > -w; no space remaining for text"
end

$width = OPTIONS.fetch(:width, 80)
$pre   = OPTIONS.fetch(:pre, 0)

$width -= $pre

def ppre(*a)
  print(' ' * $pre, *a, "\n")
end

def print_lines(prefix, suffix=prefix, lines: ARGV)
  if OPTIONS[:padding]
    (suffix = +suffix).prepend ' ' # `+suffix` in case it's the default
    prefix.concat ' '
  end

  msg_width = $width - prefix.length - suffix.length
  method = case OPTIONS[:justify]
           when :left   then :ljust
           when :right  then :rjust
           when :center then :center
           else fail "<bug: bad justify given: #$justify>"
           end

  lines.each do |line|
    ppre prefix, line.public_send(method, msg_width), suffix
  end
end

# print (1..$width+$pre).map { _1.to_s[-1] }.join, "\n" if $DEBUG

case OPTIONS[:style]
when '#'
  ppre '#' * $width
  print_lines('#')
  ppre '#' * $width
when '/'
  ppre '/' * $width
  print_lines('//')
  ppre '/' * $width
when '*'
  ppre '/', '*' * ($width - 2), ' '
  print_lines(' *', '* ')
  ppre ' ', '*' * ($width - 2), '/'
else
  abort 'unknown style %s' % OPTIONS[:style]
end
