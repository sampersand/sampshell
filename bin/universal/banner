#!/usr/bin/env ruby

################################################################################
# Banner: Surround messages in boxes, to use for separators in source files.   #
################################################################################
require 'optparse'

# The styles that are recognized
REGONIZED_STYLES = %w[# * /]

OPTS = {
  width: 80,
  pre: 0,
  style: '#',
  padding: true,
  justify: :center,
}

# Parse options
OptParse.new do |op|
  op.banner.concat ' [message ...]'

  op.accept :width do |arg|
    if arg == 'auto'
      0
    else
      Integer arg rescue raise OptParse::InvalidArgument
    end
  end

  op.accept :justify do |arg|
    case arg
    when 'l', 'left' then :left
    when 'r', 'right' then :right
    when 'c', 'center' then :center
    else raise OptParse::InvalidArgument
    end
  end

  op.on '-w', '--width=(AMNT/auto)', :width, 'Set the total line width. A width of "auto" (or 0) is the',
                                             "smallest possible that fits everything [default: #{OPTS[:width]}]"

  op.on '-p', '--pre=AMNT', Integer, 'Add AMNT spaces before the banner'
  op.on '-s', '--style=STYLE', REGONIZED_STYLES, "Use STYLE for the banner. Valid: #{REGONIZED_STYLES}. [default: #{OPTS[:style]}]"
  op.on '-j', '--justify=HOW', :justify, "Justify text either left, right, center. [default: #{OPTS[:justify]}]"

  op.on '-m', '--multiline', 'Interpret each arg as a separate line'
  op.on '-b', '--blank', 'Add a blank line before and after the banner contents'
  op.on '--[no-]padding', 'Add padding to the front and end of lines. [default]'
  op.on '-c', '--copy', 'Pipe output to pbcopy command'

  op.parse! into: OPTS rescue op.abort $!
  ARGV.empty? and abort op.help
end

# Join arguments by a space, unless `--multline` was passed
ARGV.replace [ARGV.join(' ')] unless OPTS[:multiline]

# If the user requested blank padding, add an empty line before and after the args.
if OPTS[:blank]
  ARGV.unshift ''
  ARGV.push ''
end

# If the user requested `--copy`, then pipe the output to `pbcopy` (macOS's copy command)
if OPTS[:copy]
  $stdout = IO.popen('pbcopy', 'w')
end

if OPTS[:width].zero?
  OPTS[:width] = $*.map(&:length).max + 4 # TODO: use other pres
  OPTS[:width] -= 2 unless OPTS[:padding]
end

if (OPTS[:width] - OPTS[:pre]).negative?
  abort "#{File.basename($0)}: -p > -w; no space remaining for text"
end

$width = OPTS.fetch(:width, 80)
$pre   = OPTS.fetch(:pre, 0)

$width -= $pre

def ppre(*a)
  print(' ' * $pre, *a, "\n")
end

def print_lines(prefix, suffix=prefix, lines: ARGV)
  if OPTS[:padding]
    (suffix = +suffix).prepend ' ' # `+suffix` in case it's the default
    (prefix = +prefix).concat ' '
  end

  msg_width = $width - prefix.length - suffix.length
  method = case OPTS[:justify]
           when :left   then :ljust
           when :right  then :rjust
           when :center then :center
           else fail "<bug: bad justify given: #$justify>"
           end

  lines.each do |line|
    ppre prefix, line.public_send(method, msg_width), suffix
  end
end

print (1..$width+$pre).map { _1.to_s[-1] }.join, "\n" if $DEBUG

case OPTS[:style]
when '#'
  ppre '#' * $width
  print_lines('#')
  ppre '#' * $width
when '/'
  ppre '/' * $width
  print_lines('//')
  ppre '/' * $width
when '*'
  ppre '/', '*' * ($width - 2), ' '
  print_lines(' *', '* ')
  ppre ' ', '*' * ($width - 2), '/'
else
  abort 'unknown style %s' % OPTS[:style]
end
