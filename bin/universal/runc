#!/usr/bin/env -S ruby -W0

# This file is incredibly overengineered haha.
require 'English'

def usage! success = false
  $> = $stderr unless success

  puts <<~USAGE; exit(success)
    usage: #$0 [-c compiler] [-o output] [compiler opts ...] [prelude ...] main [-- main-arguments]
    compiles C code using 'compiler', which defaults to 'cc'. 'opts' can be
    interspersed within arguments.
      - prelude is done before 'main'
      - lots of defaults are imported by default
      - P is a macro shorthand for printf(...), putchar('\\n')

    examples:
      runc -w 'enum foo { a, b }' 'printf("%s/%d", argv[1], b)' -- 34
        => 34/11

  USAGE
end

class Program
  def Program::Make_Output_File()
    ::EXECUTABLE_FILE << file = %x<mktemp>.chop # Don't rely upon `tempfile`
  rescue
    Object::const_set('EXECUTABLE_FILE', %w//)
    trap %s[EXIT], %(EXECUTABLE_FILES.each { File.delete it }) and fail('two exists')
    retry
  else
    unless $?.success? then fail('cannot make temp file') else file end
  end

  public  attr :compiler, true
  public  attr :compilerOpts, true
  private attr :prelude, true
  private attr :main, true

  def executable
    @executable ||= Program::Make_Output_File()
  end

private

  def initialize argv=ARGV
    self.compiler     = 'cc'
    self.compilerOpts = Array::new
    self.prelude      = Array::new

    self.parseOptions(argv)
  end

  def parseOptions argv
    while (arg = argv.shift()) do
      case ( arg )
      when '-h'   then usage! true
      when '-v'   then $VERBOSE = true
      when /^-c/  then self.compiler = $' || argv.shift() or usage!()
      when '--'   then break()
      when /^-.*/ then self.compilerOpts << arg
      else self.prelude << arg
      end
    end

    unless (self.main = self.prelude.pop())
      usage!
    end
  end

public

  def writeProgram
    read, write = IO.pipe()

    if ( $-v ) then
      told = DATA.tell()
      IO::copy_stream(DATA, $DEFAULT_OUTPUT)
      DATA.seek(told, IO::SEEK_SET)

      def write.write *x
        $>.write *x
        super
      end
    end

    IO::copy_stream(DATA, write)

    for $LAST_READ_LINE in ( self.prelude )
      $LAST_READ_LINE += ';' unless /^\s*#/ or /;$/
      write.print()
      ?\C-J.display(write)
    end

    printf write, <<~'C', self.main
      int main(int argc, const char **argv) {
        %s;
      }
    C

    write.close()
    return( read )
  end
end

def executeProgram! program
  out = program.writeProgram()

  system(
    program.compiler,
    '-xc',
    '-o',
    program.executable,
    '/dev/fd/10',
    *program.compilerOpts,
    0d10 => out,
    exception: true
  )
rescue Errno::ENOENT
  abort "cannot find compiler: #{program.compiler}"
rescue RuntimeError
  $@ = [] # No backtrace in exit
  raise
else
  # Don't use `exec` so we can run our `trap` to remove it
  system(
    Hash['RUNC_ARGV0', program.executable],
    Array[program.executable] * 2,
    *$ARGV
  )
end

$*.replace [ '-v', '-w', 'enum foo { a, b }', "int x;", 'printf("%s / %d", getenv("RUNC_ARGV0"), b)', '--', '34']
executeProgram! Program::new()
exit Process::last_status.exitstatus

__END__
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <limits.h>
#include <unistd.h>
#define P(...) (printf(__VA_ARGS__),putchar('\n'))
