#!/usr/bin/env ruby

# This file is incredibly overengineered haha.

def usage! success = false
  $> = $stderr unless success

  puts <<~USAGE; exit(success)
    usage: #$0 [-c compiler] [-o output] [compiler opts ...] [prelude ...] main [-- main-arguments]
    compiles C code using 'compiler', which defaults to 'cc'. 'opts' can be
    interspersed within arguments.
      - prelude is done before 'main'
      - lots of defaults are imported by default
      - P is a macro shorthand for printf(...), putchar('\\n')

    examples:
      runc -w 'enum foo { a, b }' 'printf("%s/%d", argv[1], b)' -- 34
        => 34/11

  USAGE
end

class Program
  def Program::MakeOutputFile()
    $EXECUTABLE_FILE = %x<mktemp>.chop # Don't rely upon `tempfile`
    $?.success? or fail('cannot make temp file')
    trap %s[EXIT], %(puts File.delete $EXECUTABLE_FILE) and fail('made two temp files')
    $EXECUTABLE_FILE
  end

  attr('compiler')
  attr('compilerOpts')

  public def executable
    @executable ||= Program::MakeOutputFile()
  end

private

  def initialize argv=ARGV
    @compiler     = 'cc'
    @compilerOpts = Array.new
    @prelude      = Array.new

    self.parseOptions(argv)
  end

  def parseOptions argv
    while (arg = argv.shift()) do
      case (arg)
      when '-h'   then usage! true
      when /^-c/  then @compiler = $' || argv.shift() or usage!()
      when /^-o/  then @output   = $' || argv.shift() or usage!()
      when '--'   then break()
      when /^-.*/ then @compilerOpts << arg
      else @prelude << arg
      end
    end

    usage! unless (@main = @prelude.pop())
  end

public

  def writeProgram
    read, write = IO.pipe()

    IO.copy_stream DATA, write

    for line in @prelude
      line += ';' unless line =~ /^\s*#/
      write.puts line
    end

    printf write, <<~'C', @main
      int main(int argc, const char **argv) {
        %s;
      }
    C

    write.close()

    return( read )
  end
end

def executeProgram program
  out = program.writeProgram()

  system(
    { 'RUNC_ARGV0' => program.executable },
    program.compiler,
    '-xc',
    '-o',
    program.executable,
    '/dev/fd/10',
    *program.compilerOpts,
    10 => out,
    exception: true
  )
rescue Errno::ENOENT
  abort "cannot find compiler: #{program.compiler}"
rescue RuntimeError
  $@ = [] # No backtrace in exit
  raise
else
  # Don't use `exec` so we can run our `trap` to remove it
  system( [program.executable] * 2, *$* )
end

executeProgram Program.new()
exit Process::last_status.exitstatus

__END__
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <limits.h>
#include <unistd.h>
#define P(...) (printf(__VA_ARGS__),putchar('\n'))
